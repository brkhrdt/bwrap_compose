"""Tests for the from-command CLI that generates a profile from a bwrap command."""

import json
from pathlib import Path

import yaml
from typer.testing import CliRunner

from bwrap_compose.cli import app, _extract_special_mounts

runner = CliRunner()


class TestExtractSpecialMounts:
    def test_extracts_tmpfs(self):
        profile = {"args": ["--tmpfs", "/tmp", "--unshare-pid"]}
        result = _extract_special_mounts(profile)
        assert result["tmpfs"] == ["/tmp"]
        assert result["args"] == ["--unshare-pid"]

    def test_extracts_dev_and_proc(self):
        profile = {"args": ["--dev", "/dev", "--proc", "/proc"]}
        result = _extract_special_mounts(profile)
        assert result["dev"] == ["/dev"]
        assert result["proc"] == ["/proc"]
        assert result["args"] == []

    def test_leaves_other_args(self):
        profile = {"args": ["--unshare-pid", "--die-with-parent"]}
        result = _extract_special_mounts(profile)
        assert result["args"] == ["--unshare-pid", "--die-with-parent"]
        assert "tmpfs" not in result

    def test_empty_args(self):
        profile = {"args": []}
        result = _extract_special_mounts(profile)
        assert result["args"] == []


class TestFromCommandCLI:
    def test_basic_profile_output(self):
        result = runner.invoke(app, [
            "from-command",
            "bwrap --ro-bind / / --setenv A 1 -- /bin/sh",
        ])
        assert result.exit_code == 0
        profile = yaml.safe_load(result.output)
        assert profile["mounts"] == [{"host": "/", "container": "/", "mode": "ro"}]
        assert profile["env"] == {"A": "1"}
        assert profile["run"] == ["/bin/sh"]

    def test_rw_bind(self):
        result = runner.invoke(app, [
            "from-command",
            "bwrap --bind /tmp /tmp -- /bin/echo",
        ])
        assert result.exit_code == 0
        profile = yaml.safe_load(result.output)
        assert profile["mounts"] == [{"host": "/tmp", "container": "/tmp", "mode": "rw"}]

    def test_tmpfs_extracted_to_key(self):
        result = runner.invoke(app, [
            "from-command",
            "bwrap --ro-bind / / --tmpfs /tmp --proc /proc -- /bin/sh",
        ])
        assert result.exit_code == 0
        profile = yaml.safe_load(result.output)
        assert "/tmp" in profile["tmpfs"]
        assert "/proc" in profile["proc"]
        # --tmpfs and --proc should not appear in args
        assert "--tmpfs" not in profile.get("args", [])
        assert "--proc" not in profile.get("args", [])

    def test_preserves_args(self):
        result = runner.invoke(app, [
            "from-command",
            "bwrap --ro-bind / / --unshare-pid --unshare-net -- /bin/sh",
        ])
        assert result.exit_code == 0
        profile = yaml.safe_load(result.output)
        assert "--unshare-pid" in profile["args"]
        assert "--unshare-net" in profile["args"]

    def test_no_run_when_absent(self):
        result = runner.invoke(app, [
            "from-command",
            "bwrap --ro-bind / /",
        ])
        assert result.exit_code == 0
        profile = yaml.safe_load(result.output)
        assert "run" not in profile

    def test_output_to_file(self, tmp_path):
        out = tmp_path / "profile.yaml"
        result = runner.invoke(app, [
            "from-command",
            "bwrap --ro-bind / / --setenv X 1 -- /bin/sh",
            "--output", str(out),
        ])
        assert result.exit_code == 0
        assert out.exists()
        profile = yaml.safe_load(out.read_text())
        assert profile["env"] == {"X": "1"}

    def test_roundtrip_combine(self, tmp_path):
        """Profile generated by from-command should be usable by combine."""
        out = tmp_path / "generated.yaml"
        runner.invoke(app, [
            "from-command",
            "bwrap --ro-bind / / --setenv A 1 --unshare-pid -- /bin/echo hello",
            "--output", str(out),
        ])
        result = runner.invoke(app, ["combine", str(out), "--dry-run"])
        assert result.exit_code == 0
        assert "--ro-bind" in result.output
        assert "A" in result.output
